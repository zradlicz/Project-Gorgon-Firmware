; SDI-12 UART PIO Program
; Implements 1200 baud, 7 data bits, even parity, 1 stop bit
; Clock divider should be set for 1200 baud from 125MHz system clock

.program sdi12_tx
.side_set 1 opt

; Transmit one byte (7 data bits + even parity + 1 stop bit)
; Data in OSR, shifts out LSB first
; Side-set pin is the SDI-12 data line

.wrap_target
    pull       side 1 [7]    ; Pull byte from TX FIFO, default high (marking)
    set x, 6   side 0 [7]    ; Start bit (spacing/low), load bit counter (7 bits total)
    set y, 0                 ; Initialize parity counter
bitloop:
    out pins, 1       [6]    ; Shift out data bit
    mov osr, ::osr           ; Copy OSR bit 0 to ISR for parity calculation
    jmp !osre skip           ; If bit was 0, skip parity increment
    jmp x-- bitloop          ; Decrement counter and continue if more bits
skip:
    out null, 1              ; Consume the bit we just sent
    jmp x-- bitloop   [6]    ; Loop for remaining bits
    ; Calculate and send parity bit (even parity)
    mov pins, y       [7]    ; Send parity bit
    nop               side 1 [7]  ; Stop bit (marking/high)
.wrap

.program sdi12_rx
; Receive one byte (7 data bits + even parity + 1 stop bit)
; Input on IN pin, pushes received byte to RX FIFO

.wrap_target
start:
    wait 0 pin 0             ; Wait for start bit (spacing/low)
    set x, 6         [7]     ; Load bit counter (7 data bits), delay to center of bit
    set y, 0                 ; Initialize parity counter
bitloop:
    in pins, 1       [6]     ; Sample data bit into ISR
    jmp pin parity_inc       ; If bit is 1, increment parity
    jmp x-- bitloop          ; Continue to next bit
parity_inc:
    jmp x-- bitloop          ; Continue to next bit (parity handled separately)
    ; Receive parity bit
    in pins, 1       [7]     ; Sample parity bit
    ; Receive stop bit
    wait 1 pin 0     [7]     ; Wait for stop bit (marking/high)
    push                     ; Push received byte to FIFO
.wrap

.program sdi12_break_detect
; Detect SDI-12 break signal (12ms minimum spacing state)
; Uses counter to measure pulse width

.wrap_target
    wait 1 pin 0             ; Wait for spacing (high/5V) state
    set x, 0                 ; Reset counter
count_loop:
    jmp pin continue         ; If still high, continue counting
    jmp check_break          ; Pin went low, check if it was long enough
continue:
    jmp x-- count_loop [31]  ; Count with maximum delay
    irq set 0                ; Signal break detected via IRQ
    jmp start_over
check_break:
    ; Would need to check if x indicates >= 12ms
    ; This is simplified - actual implementation needs clock divider tuning
start_over:
    wait 0 pin 0             ; Wait for low before starting over
.wrap
